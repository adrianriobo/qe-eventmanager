package ocp

import (
	"encoding/json"
	"sync"

	crcPipelines "github.com/adrianriobo/qe-eventmanager/pkg/crc/pipelines"
	"github.com/adrianriobo/qe-eventmanager/pkg/util"
	"github.com/adrianriobo/qe-eventmanager/pkg/util/logging"
	umb "github.com/adrianriobo/qe-eventmanager/pkg/util/umb"
	stomp "github.com/go-stomp/stomp/v3"
)

const (
	buildComplete string = "VirtualTopic.qe.ci.product-scenario.ascerra.build.complete"
	testComplete  string = "VirtualTopic.qe.ci.product-scenario.ascerra.test.complete"
	// testError     string = "VirtualTopic.qe.ci.product-scenario.ascerra.test.error"
)

type ProductScenarioBuild struct {
	connection   umb.UMBConnection
	subscription *stomp.Subscription
	consumers    *sync.WaitGroup
	handlers     *sync.WaitGroup
}

func New(connection *umb.UMBConnection) *ProductScenarioBuild {
	return &ProductScenarioBuild{connection: *connection}
}

func (p *ProductScenarioBuild) Init() {
	p.subscription, _ = p.connection.FailoverSubscribe("Consumer.psi-crcqe-openstack.1231231232."+buildComplete, stomp.AckAuto)
	// group of consumers
	p.consumers = &sync.WaitGroup{}
	// group of handlers
	p.handlers = &sync.WaitGroup{}
	// async consume
	p.consumers.Add(1)
	go p.consume()
}

func (p *ProductScenarioBuild) Finish() {
	if err := p.subscription.Unsubscribe(); err != nil {
		logging.Error(err)
		// Force consume as finished ?
		p.consumers.Done()
	}
	p.consumers.Wait()
	p.handlers.Wait()
}

// TODO add selector based on regex??
func (p *ProductScenarioBuild) consume() {
	defer p.consumers.Done()
	for p.subscription.Active() {
		msg, err := p.subscription.Read()
		if err != nil {
			if !p.subscription.Active() {
				break
			}
			logging.Errorf("Error reading from topic: %s. %s", buildComplete, err)
			break
		}
		p.handlers.Add(1)
		go p.handle(msg)
	}
}

func (p *ProductScenarioBuild) handle(msg *stomp.Message) {
	// when finish remove from group
	defer p.handlers.Done()
	// heavy consuming may regex over string
	var event BuildComplete
	// logging.Debugf("Print message %+v", string(msg.Body[:]))
	if err := json.Unmarshal(msg.Body, &event); err != nil {
		logging.Error(err)
	}
	for _, product := range event.Artifact.Products {
		if product.Name == "openshift" {
			// pipelinerunstatus, err := crcPipelines.Run(product.Id, util.GenerateCorrelation())
			_, err := crcPipelines.Run(product.Id, util.GenerateCorrelation())
			if err != nil {
				logging.Error(err)
			}
			// We will take info from status to send back the results
		}
	}

	// logging.Debugf("Start PipelineRun based on %s", event)
	// Create N pipelineruns -> Evolve into CRD from PSI-Operator
	// On each pipelirun launch a pulling for results -> Evolve on listen back to some async mechanism generated by PSI-Operator
	// Send back message to interop
	// this shows with bad format
	// if err := msg.Conn.Ack(msg); err != nil {
	// 	logging.Error(err)
	// 	// as we can not ack we should not process so
	// 	// we need to run some compensation
	// 	// and retry to process it
	// }

	// Mock response
	var response TestComplete
	mockResponse(&event, &response)
	if err := p.connection.FailoverSend("/topic/"+testComplete, response); err == nil {
		logging.Error(err)
	}
}

func mockResponse(source *BuildComplete, response *TestComplete) {
	response.Artifact = source.Artifact
	response.Run = Run{
		URL: "https://crcqe-jenkins-csb-codeready.cloud.paas.psi.redhat.com/view/qe-bundle-baremetal/job/qe/job/bundle_baremetal_macos14-brno/284",
		Log: "https://crcqe-jenkins-csb-codeready.cloud.paas.psi.redhat.com/view/qe-bundle-baremetal/job/qe/job/bundle_baremetal_macos14-brno/284/console"}
	response.Test = Test{
		Category:  "interoperability",
		Namespace: "interop",
		TestType:  "product-scenario",
		Result:    "passed",
		Runtime:   "1800",
		XunitUrls: []string{
			"https://crcqe-jenkins-csb-codeready.cloud.paas.psi.redhat.com/view/qe-bundle-baremetal/job/qe/job/bundle_baremetal_macos14-brno/284/console",
			"https://crcqe-jenkins-csb-codeready.cloud.paas.psi.redhat.com/view/qe-bundle-baremetal/job/qe/job/bundle_baremetal_macos14-brno/284/console"}}
}
